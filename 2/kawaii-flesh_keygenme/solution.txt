The main function checks if the command line arguments are exactly 3, then a function is executed on the 2nd argument (name). More on this later.
After the function, the first character of the name is saved in a variable and also the length of the first argument, which is the program's name.
Finally, the last argument, that is the key, is converted into an integer number.

The function mentioned earlier calculates the sum of the name's characters, which I'll call a checksum.

Finally, if the key as int is equal to the bitwise xore between the checksum and the first character of the name multiplied by 3, left shifted of X positions where X is the logical and between the program's name length and 0x1f, then the key is valid

Trying this in a python shell, if the name is "A", then its ordinal value is 65.
65 xored with 65 * 3 is 130.
130 left shifted by the length of the program's name, "./keygenme", AND-ed with 0x1f is 133120, which ends up to be a valid key.

The following python program is a key generator for this challenge. For some reason, the keys are valid if generated by considering program_name_length - 1, they are equal to 2 * actual_key if this is not done



import sys

def name_chksm(name):
  sum = 0
  for c in name:
    sum += ord(c)
  return sum


if __name__ == '__main__':
  argv = sys.argv
  if len(argv) != 2:
    print('Usage: python3 ./keygenme [name]')
    exit(0)
  name = argv[1]
  chksm = name_chksm(name)
  first_name_char = ord(name[0])
  program_name_length = len(argv[0]) - 1
  key = (chksm ^ (first_name_char * 3)) << (program_name_length & 0x1f)
  print('Key: ' + str(key))
  exit(0)