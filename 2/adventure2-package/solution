Мой салют для crackme -> https://www.crackmes.one/crackme/5d1a344033c5d410dc4d0c3e
1. Открываем crackme в r2:
r2 -A adventure2
2. Прыгаем на main и выводим дизассемблированный листинг:
s main
pdf
3. Смотрим какие проверки и чего происходят:
1) Первая проверка на количество аргументов.
Кол-во аргументов КС должно быть больше одного, то-есть
запускать crackme мы должны так:
./adventure2 ...
2) Вторая проверка:

mov rax, qword [s1]
add rax, 8
mov rax, qword [rax]
add rax, 1
mov rdi, rax
call sym.imp.strlen
mov rdx, rax
mov rax, qword [s1]
add rax, 8
mov rax, qword [rax]
movzx eax, byte [rax]
movsx eax, al
sub eax, 0x30
cdqe
cmp rdx, rax
je 0x909

Если коротко, то если мы запустили crackme так -> ./adventure2 1234
то:
rdx = 3 (длина нашей строки - 1)
rax = 1(0x31 - 0x30) (первый байт нашей строки - 0x30)

Тогда первый символ должен быть символом, за которым следует кол-во
любых символов, равное коду нашего символа минус 0x30
примеры:
0
1a
2aa
3aaa
...

Я запустил так: ./adventure2 1k

3) Третья проверка(финальная)
Прыгаем на step2:
s sym.step2
pdf

mov rax, qword [var_30h]
add rax, 8
mov rax, qword [rax]
movzx eax, byte [rax]
movsx eax, al
add eax, 0xf
mov dword [var_14h], eax

var_14h = код нашего символа + 0xf
В нашем случае(1k) var_14h = 0x31 + 0xf = 0x40; 64; '@'

Нас просят решить пример:
"what's 1 + 3 * 5 ?"

call sym.imp.__isoc99_scanf ; int scanf(const char *format)
mov eax, dword [var_1ch]
cmp dword [var_14h], eax

Но в ответ мы вводим значение var_1ch, то есть 64

Чтобы найти правильный ответ для вашего случая
можно воспользоваться средствами radare2:
? 'your first symbol in argv[1]' + 0xf

? '1' + 0xf
int32   64

Thanks for crackme ker2x!)

P.S.:
Ошибка сегментирования (стек памяти сброшен на диск)
