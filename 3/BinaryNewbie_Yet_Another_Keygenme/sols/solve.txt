This crackme is a Linux crackme. It has a screwed ELF header and gdb cannot properly debug it. And it also causes problem for disassemblers. To start with, we need to first fix the header. 

After some invetigation of the ELF file header, we find the offset of section headers and the number of section headers are both set to 0xff. For ELF, sections are not critical for the execution (segments are). So the prorgam can execute properly even if the section information is twisted. By observing some corect ELF files, it can be found the section headers are often at the end of the binary. For this crackme, the section offset to section headers is 0x3128 and we have 0x1b secitons. After we fix the ELF header, gdb can work with it without problem. Here I recommand the Kaitai IDE (https://ide.kaitai.io/) to work with binary structures. Just upload the ELF file and select the ELF.ksy to get started. 

This programs takes two two parameters: a name and a file which contains a password. The name must be ten chars long and the password cannot be longer than 50 chars. 

The core check is at 0x1bb0. It branches on whether the lenght of the name is equal to the length of the password. The branch for the equal case is not easy to follow, but the other branch is quite obvious. Indeed, it calculates a sum and a multiplication and requires that:

rcx = (r10 - r9) % (r9 + r10)
rcx % 0x10 in [1, 3, 9]

where r10 is the multiplication, and the r9 is the sum. r9 and r10 are calculated as such: 

r9 = 0
r10 = 1
for k in range(len(data) - 1):
    for i in range(len(name)):
        val = (ord(name[i]) + (ord(data[k]) ^ i)) & 0xf
        val2 = (ord(data[k]) + i) | (i ^ k)
        r9 += val * 2
        r10 *= (val | val2)
        r10 &= 0xffffffffffffffff


The quickest way to find valid name-password pair is to try different passwords. Below are three I found:

('0123456789', 'EJUkSN3W')
('hevk9a3f7b', 'WBkNoN5U')
('jf721hdp0q', 'CpAD7tGq')